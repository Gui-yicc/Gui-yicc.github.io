{"meta":{"title":"陈工","subtitle":"我见青山多妩媚，料青山、见我应如是。","description":"陈燕飞的博客","author":"妫乙","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2017-08-31T07:09:54.000Z","updated":"2017-12-14T09:26:18.010Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"❀❀❀ 北京 前端 陈 chenyanfei_m@foxmail.com❀❀❀"}],"posts":[{"title":"解锁使用chrome调试微信公众号的新姿势","slug":"解锁使用chrome调试微信公众号的新姿势","date":"2017-12-10T15:52:03.000Z","updated":"2017-12-17T17:19:27.559Z","comments":true,"path":"2017/12/10/解锁使用chrome调试微信公众号的新姿势/","link":"","permalink":"http://yoursite.com/2017/12/10/解锁使用chrome调试微信公众号的新姿势/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在开发微信公众号可以很方便的使用微信开发工具来进行开发。但是当我尝试使用微信开发工具来查看没有开发权限的微信公众号的源码的时候就遇到了阻碍——并不能查看公众号的代码，因为没有开发权限。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后尝试使用fiddler来进行抓包分析，但是发现这种方式对于我查看源码的目的来说并不是特别方便。然后网上的inspect方式也比较繁琐。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后想起原来通过微信内置的浏览器的配置清除过cookie，可能还会有一些其他的配置会对查看源码有帮助，果不其然，在信息 -&gt; TBS settings -&gt; 是否打开TBS内核Inspector调试功能，勾选上。然后就可以像hybrid app一样愉快的使用chrome的inspect来查看和调试代码啦~","categories":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/categories/chrome/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"}]},{"title":"chrome调试新姿势，获取元素最终的css和使用async报error的问题","slug":"琐碎-chrome-css","date":"2017-12-03T01:47:20.000Z","updated":"2017-12-17T17:18:03.628Z","comments":true,"path":"2017/12/03/琐碎-chrome-css/","link":"","permalink":"http://yoursite.com/2017/12/03/琐碎-chrome-css/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过在代码内添加debugger的方式来打断点,原来打断点都是先console一下找到代码的位置,现在可以发现可以直接加在代码里，当然，如果使用eslint的airbnb规则默认是被禁止的哈哈 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用async报错的问题，添加babel-polyfill，然后在webpack入口加上即可 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过getComputedStyle可以获取到元素render后最终使用的css，此属性为只读属性","categories":[{"name":"琐碎","slug":"琐碎","permalink":"http://yoursite.com/categories/琐碎/"}],"tags":[{"name":"遇到的一些小问题","slug":"遇到的一些小问题","permalink":"http://yoursite.com/tags/遇到的一些小问题/"}]},{"title":"React.PureComponent","slug":"React.PureComponent","date":"2017-11-26T04:36:40.000Z","updated":"2017-12-17T16:50:47.546Z","comments":true,"path":"2017/11/26/React.PureComponent/","link":"","permalink":"http://yoursite.com/2017/11/26/React.PureComponent/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React.PureComponent与React.Component的区别在于PureComponent与React通过prop和state的前对比实现了shouldComponentUpdate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道只要执行一次setState默认就会render一次，当使用PureComponent时，react会浅层次的对state和prop进行diff，这样可以在一定程度上提高性能。由于是浅对比的，所以深层对象可能会出错，还有就是PureComponent与忽略整个组件的子级，所以需要确保子级组件也是Pure的。","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"e.stopPropagation()和e.preventDefault()","slug":"关于e.stopPropagation()和e.preventDefault()","date":"2017-11-19T10:20:37.000Z","updated":"2017-11-27T09:57:14.982Z","comments":true,"path":"2017/11/19/关于e.stopPropagation()和e.preventDefault()/","link":"","permalink":"http://yoursite.com/2017/11/19/关于e.stopPropagation()和e.preventDefault()/","excerpt":"","text":"e.stopPropagation() //用来阻止事件的冒泡e.preventDefault() //用来阻止事件默认的行为return false //两者皆阻止","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"工作中遇到的一些小问题","slug":"遇到的小问题","date":"2017-11-12T13:55:36.000Z","updated":"2017-11-27T09:51:34.195Z","comments":true,"path":"2017/11/12/遇到的小问题/","link":"","permalink":"http://yoursite.com/2017/11/12/遇到的小问题/","excerpt":"","text":"通过添加在文件头部添加 /* eslint-disable */ 来忽略eslint qq浏览器 0.01rem宽度的border没有效果, 需要使用1px 0.5px line的通常做法是使用scale和after,before伪类 即使字体行高等于容器高度也有可能不垂直居中, 这种情况有可能是字体大小为奇数导致的 img有莫名空白的问题123div&#123;font-size: 0&#125;img&#123;display: block&#125;img&#123;vertical-align: top&#125; 相对来说第二种给人感觉更为正常 为a标签添加一个形如”tel:电话号码”这样的href属性可以唤起打电话","categories":[{"name":"琐碎","slug":"琐碎","permalink":"http://yoursite.com/categories/琐碎/"}],"tags":[{"name":"遇到的一些小问题","slug":"遇到的一些小问题","permalink":"http://yoursite.com/tags/遇到的一些小问题/"}]},{"title":"常见的前端算法","slug":"前端常见算法","date":"2017-11-05T08:10:32.000Z","updated":"2017-11-27T09:26:19.267Z","comments":true,"path":"2017/11/05/前端常见算法/","link":"","permalink":"http://yoursite.com/2017/11/05/前端常见算法/","excerpt":"","text":"数组乱序1[3,1,2].sort(() =&gt; Math.random() - 0.5) 数组去重12345678[...new Set([1,1,2,3])][1,1,2,3].filter((ele,index,arr) =&gt; !arr.includes(ele,index+1))Array.property.reducefor循环 统计字符串出现最多的字符123456const str = 'sdsdfjsdjss'let result = []for(let i=0;i&lt;str.length;i++)&#123; result.push(str.match(new RegExp(str[i],'g')))&#125;const mostCountStr = result.sort((a,b) =&gt; b.length-a.length)[0][0] 快排1234567891011121314151617181920212223242526const quickSort = (arr) =&gt; &#123; if(arr.length &lt;= 1)&#123; return arr &#125; let middleKey = Math.floor(arr.length/2) let middleValue = arr.splice(centerKey,1)[0] let reduceResult = arr.reduce((acc,ele,index,arr) =&gt; &#123; if( ele&gt;=middleValue )&#123; acc.right.push(ele) &#125;else&#123; acc.left.push(ele) &#125; return acc &#125;,&#123;left:[],right:[]&#125;) return [...quickSort(reduceResult.left),middleValue,...quickSort(reduceResult.right)]&#125;``` ### 不借助临时变量, 进行两个整数的交换 ###```javascriptlet a = 1, b = 2[b,a] = [a,b]let a = 1, b = 2b = b - aa = a + bb = a - b 找出数组的最大差值123456const arr = [65,4564,65,4,564,6]const sortResult = arr.sort((a,b) =&gt; a - b)const differenceValue = sortResult[sortResult.length-1] - sortResult[0]//获取数组中的最大/最小值Math.max(...[65,4564,65,4,564,6]) 生成长度为n且每个元素都为n的数组1new Array(n).fill(n)","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"利用react高阶组件与context实现简单的状态管理","slug":"利用react高阶组件与context实现简单的状态管理","date":"2017-10-29T12:20:05.000Z","updated":"2017-11-12T23:37:38.552Z","comments":true,"path":"2017/10/29/利用react高阶组件与context实现简单的状态管理/","link":"","permalink":"http://yoursite.com/2017/10/29/利用react高阶组件与context实现简单的状态管理/","excerpt":"","text":"首先我们得知道react的context的用法：通过在context提供者中添加childContextTypes和getChildContext来添加context，然后在子组件中通过contextTypes来获取参数，通过它我们可以将数据跨组件传送。以及高阶组件的作用：高阶组件实质上就是一个函数，这个函数接受一个组件作为参数，并返回一个新的组件。 想要实现简单的状态的管理，我们需要一个存储数据的store和一个可以改变这个store内数据的动作。代码如下：react123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'class Provider extends Component &#123; //选择需要放在context上的数据和方法 static childContextTypes = &#123; store: PropTypes.object, setStore: PropTypes.func &#125; getChildContext() &#123; return &#123; store: this.state.store || &#123;&#125;, setStore: this.setStore &#125; &#125; //通过此方法来修改store内的数据 setStore = (data) =&gt; &#123; this.setState(&#123; store: &#123; ...this.state.store, ...data &#125; &#125;) &#125; //初始时的数据，如果没有从组件外传入则为空对象 state = &#123; store: this.props.store || &#123;&#125; &#125; render() &#123; return this.props.children &#125;&#125;const connect = WrapComponent =&gt; &#123; //返回一个新的传入了store与setStore方法的组件 return class connect extends Component &#123; //通过contextTypes来选择需要使用context内的数据或方法 static contextTypes = &#123; store: PropTypes.object, setStore: PropTypes.func &#125; render() &#123; const &#123; store, setStore &#125; = this.context const props = &#123; ...this.props, store, setStore &#125; return &lt;WrapComponent &#123;...props&#125;&gt;&lt;/WrapComponent &gt; &#125; &#125;&#125;export &#123; Provider, connect &#125; 需要使用时通过在组件树的高层初始化store，然后在需要使用store的子组件外通过此代码导出的connect方法包裹此子组件即可通过组件的props拿到store和setStore。","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"对redux设计的理解","slug":"关于redux如此设计的理解","date":"2017-10-22T13:15:15.000Z","updated":"2017-10-23T03:46:36.864Z","comments":true,"path":"2017/10/22/关于redux如此设计的理解/","link":"","permalink":"http://yoursite.com/2017/10/22/关于redux如此设计的理解/","excerpt":"","text":"以前对于redux只是照着文档用，闲下来想了想为什么redux要这样设计呢？如果自己想实现一个状态管理的方案该会是怎样的呢？ 首先，当遇到很多状态需要集中管理的时候，我们很容易能想到通过顶层store来对状态进行集中管理，如果子组件需要此状态，可以通过hoc将store内的数据通过props传进来，与此同时传入一个可以改变顶层store内的数据的方法。这样便实现了一个最简单的状态管理方案。 然而，就这样粗浅的设计肯定会有很多的问题 比如：通常顶层的store通常会非常大，我们很可能不需要所有的store内的数据，这时可以在hoc上传一个参数，来选择性的传入需要的数据 比如：现在我们通过changeStore方法来改变store内的数据，但是，数据如何处理呢?这是一个问题，原来我们只是简单的通过传入一个对象，比如在store内的数据为{data:1}，我们通过changeStore({data:2})来将store内的数据进行改变，当我们传入的并不是一个满意的值的时候，我们就需要在changeStore和store中间加一层用来处理数据 没时间先写到这儿，这是我对redux如此设计的原因的理解，以上~","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"关于JS的数据绑定","slug":"关于JS的数据绑定","date":"2017-10-15T07:23:17.000Z","updated":"2017-11-08T10:54:37.730Z","comments":true,"path":"2017/10/15/关于JS的数据绑定/","link":"","permalink":"http://yoursite.com/2017/10/15/关于JS的数据绑定/","excerpt":"","text":"发布者-订阅者模式，如backbone.js 脏值检查，如angular，对常用的dom及xhr事件做了封装，在其中会从rootscope开始进行遍历，检查所有的watcher，并不是定时轮询检查 Object.defineProperty，此属性可以设置对象的get和set，在对对象进行读写的时候就会触发相应的函数。示例代码如下： 12345678910111213let boundObj = &#123; a: 1 &#125;let resObj = &#123;&#125;boundObj.bValue = boundObj.aObject.defineProperty(boundObj, a, &#123; get()&#123; return boundObj.bValue &#125;, set(newValue)&#123; boundObj.bValue = newValue resObj.b = newValue return newValue &#125;&#125;) resObj对象的b属性便与boundObj的a属性绑定了 proxy，通过设置set来进行绑定，相对于Object.defineProperty来说更加简洁，不再需要中间变量123456789const boundObj = &#123; a: 1 &#125;let resObj = &#123;&#125;boundObj.proxy = new Proxy(boundObj,&#123; set(target, prop, value, receiver)&#123; target[prop] = value resObj[prop] = value return true &#125;&#125;)","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"移动端页面宽高设置","slug":"移动端页面宽高设置","date":"2017-10-05T01:08:47.000Z","updated":"2017-10-05T01:16:50.337Z","comments":true,"path":"2017/10/05/移动端页面宽高设置/","link":"","permalink":"http://yoursite.com/2017/10/05/移动端页面宽高设置/","excerpt":"","text":"原来设置移动端页面蠢蠢的从html标签body标签一路往下设置宽高为100%，都忘了12345.root&gt;div&#123; position:absolute; width:100%; height:100% &#125; 这种写法了，蠢哭","categories":[{"name":"遇到的值得记下来的小点","slug":"遇到的值得记下来的小点","permalink":"http://yoursite.com/categories/遇到的值得记下来的小点/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"flex使用复习","slug":"flex使用总结","date":"2017-10-05T00:18:35.000Z","updated":"2017-10-05T01:01:05.194Z","comments":true,"path":"2017/10/05/flex使用总结/","link":"","permalink":"http://yoursite.com/2017/10/05/flex使用总结/","excerpt":"","text":"在日常学习和工作中使用flex也有一段时间了，刚好现在有空闲时间，来对flex再复习一遍吧 flex相对与传统的css布局可以用更少的代码达到相同的目的，尤其在常用的布局上，使用flex可以很轻松的达到目的。 首先通过display:flex或display:inline-flex来为一个容器指定为flex布局。当指定为flex布局后，容器内的子元素的float，clear，vertical-align将会失效。容器默认的轴为从左上角开始，向右为水平的主轴，向下为垂直的交叉轴。 flex容器可以设置的6个属性。 flex-direction决定了主轴的方向，可以为row：从左往右（default);row-reverse：从右往左；column：从上往下；column-reverse：从下往上。 flex-warp决定了容器内的元素是否能够换行，nowrap：顾名思义，不换行；wrap：换行；wrap-reverse：倒序换行。 flex-flow为flex-direction和flex-wrap属性的简写，默认为row nowrap。 justify-content决定了元素在主轴上如何对齐。flex-start：靠主轴开始的地方对齐；flex-end：靠主轴接受䣌地方对齐；center：居中对齐；space-between：两端元素在两笔，中间元素均分空间对齐；space-around：两端元素有一段空间，中间元素均分剩余空间。 align-items决定了容器内元素在交叉轴上如何对齐。flex-start：交叉轴起点对齐；flex-end：交叉轴终点对齐；center：居中对齐；stretch：如果元素未设置高度或为auto，那么元素将为容器高度的100%；baseline：以容器内的第一行文字的基线对齐。 align-content决定了容器内有多根轴线时的对齐方式，如果只有一根轴线，那么设置此属性无效。同样的，可以为flex-start，flex-end，center，space-between，space-around，stretch。 flex容器内元素可设置的值 order决定了元素的排列顺序，默认为0 flex-grow决定了元素的放大比例，即除了元素已经确定了的空间之外的空间的比例，如果flex-grow小于1，那么就是直接将剩余宽度乘以flex-grow的值而不会再计算比例，flex-grow会受到max-width的影响，max-width的优先级更高。 flex-shark用于在空间不够时控制元素的收缩，比如只有一个元素设置了这个，那么这个元素将会被收缩至合适的宽度。 flex-basis决定了元素在分配多余的空间之前占的主轴的空间。默认为auto flex为flex-grow，flex-shrink，flex-basis的简写，默认为0 1 auto。如果为auto则为1 1 auto，如果为none则为0 0 auo，如果为1则为1 1 0。 align-self属性为单个元素设置与其他元素不一样的对齐方式。优先级高于align-items。默认为auto，即继承父元素的align-items属性。如果没有父元素则为stretch。 总而言之，flex-grow用于将剩余空间按比例分配给元素，flex-shark用于将超出部分按比例分配给元素。 此篇总结借鉴了网上一些教程，在此处感谢他们♥","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://yoursite.com/tags/flex/"}]},{"title":"关于移动端的布局问题","slug":"关于移动端的布局问题","date":"2017-09-24T02:54:54.000Z","updated":"2017-09-25T03:33:56.381Z","comments":true,"path":"2017/09/24/关于移动端的布局问题/","link":"","permalink":"http://yoursite.com/2017/09/24/关于移动端的布局问题/","excerpt":"","text":"关于移动端常见的上下bar中间content scroll的布局，我原来的写法是content height:100%，然后再把上下bar fix在screen的上下，然而这样的布局是有很大的问题的。首先是滚动条的问题, 当以上面的方法来进行布局的时候，滚动区域位于上下bar之间, 滚动条却可以滚动到屏幕的最上方，这明显不符合直观的UI逻辑；二是很多时候下方的bar都是一个输入框，而在ios中fixed的定位可能会出现bug：当键盘出现时，此bar很可能会被弹到screen的中间。所以自己想了想该如何布局比较好，总结如下：HTML：1234567&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"scrollContainer\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/div&gt; CSS：123456789101112131415161718.container&#123; position: absolute; width: 100%; height: 100%;&#125;.header, .footer&#123; height: 50px;&#125;.scrollContainer&#123; margin: -50px 0; padding: 50px 0; height: 100%; box-sizing: border-box;&#125;.content&#123; height: 100%; overflow-y: scroll;&#125; 如果使用flex:1234567891011121314.container&#123; position: absolute; display: flex; flex-direction: column; height: 100%; width: 100%;&#125;.header,.footer&#123; flex: 0 0 50px&#125;.scrollContainer&#123; flex: 1; overflow-y: scroll;&#125; 相对于传统css布局，flex使用更少的css和html即可达到想要的效果","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"fetch发送请求携带cookie","slug":"fetch发送请求携带cookie","date":"2017-09-10T05:14:11.000Z","updated":"2017-09-11T04:39:05.764Z","comments":true,"path":"2017/09/10/fetch发送请求携带cookie/","link":"","permalink":"http://yoursite.com/2017/09/10/fetch发送请求携带cookie/","excerpt":"","text":"fetch默认不发送cookie , 发送cookie需要配置credential为include , 还不行? 服务器端配置Access-Control-Allow-Credentials为true , 还不行的话看看remote adress是不是你请求的那个地址 , 还有就是cookie是不是保存在请求的地址的下面","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"fetch","slug":"fetch","permalink":"http://yoursite.com/tags/fetch/"}]},{"title":"build文件的相对路径","slug":"build文件的相对路径","date":"2017-09-09T12:15:30.000Z","updated":"2017-09-10T05:30:44.274Z","comments":true,"path":"2017/09/09/build文件的相对路径/","link":"","permalink":"http://yoursite.com/2017/09/09/build文件的相对路径/","excerpt":"","text":"通过在package.json内添加homepage可以修改打包后的路径","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"关于es6的async","slug":"关于es6的async","date":"2017-09-08T11:40:36.000Z","updated":"2017-09-10T05:33:56.900Z","comments":true,"path":"2017/09/08/关于es6的async/","link":"","permalink":"http://yoursite.com/2017/09/08/关于es6的async/","excerpt":"","text":"async返回的是一个promise , 所以在内部return后需要then来拿async返回的值 , 同时 , 在内部使用Promise.resolve(value) , 外部通过then也不能获取值","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"关于chrome请求发送不出去的问题","slug":"关于chrome请求发送不出去的问题","date":"2017-09-07T12:15:42.000Z","updated":"2017-10-05T01:17:28.926Z","comments":true,"path":"2017/09/07/关于chrome请求发送不出去的问题/","link":"","permalink":"http://yoursite.com/2017/09/07/关于chrome请求发送不出去的问题/","excerpt":"","text":"如果发现浏览器发送请求发送不出去 , 最好看下是不是被浏览器广告插件一类的东西拦截了 , 装了Adblock Plus插件的人的血泪教训233","categories":[{"name":"遇到的值得记下来的小点","slug":"遇到的值得记下来的小点","permalink":"http://yoursite.com/categories/遇到的值得记下来的小点/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"}]},{"title":"请求参数为中文的兼容性问题","slug":"请求参数为中文的兼容性问题","date":"2017-09-05T13:54:35.000Z","updated":"2017-10-05T01:17:40.698Z","comments":true,"path":"2017/09/05/请求参数为中文的兼容性问题/","link":"","permalink":"http://yoursite.com/2017/09/05/请求参数为中文的兼容性问题/","excerpt":"","text":"请求中有可能传中文的 , 需要先使用encodeURIComponent将参数进行转码","categories":[{"name":"遇到的值得记下来的小点","slug":"遇到的值得记下来的小点","permalink":"http://yoursite.com/categories/遇到的值得记下来的小点/"}],"tags":[]},{"title":"antd-mobile修改主题样式的问题","slug":"react-antd-mobile修改主题样式的问题","date":"2017-08-29T07:53:33.000Z","updated":"2017-09-25T05:11:17.824Z","comments":true,"path":"2017/08/29/react-antd-mobile修改主题样式的问题/","link":"","permalink":"http://yoursite.com/2017/08/29/react-antd-mobile修改主题样式的问题/","excerpt":"","text":"方法为通过less-loader的modifyVars来修改原来的默认less，需要安装style-loader，css-loader，less-loader，postcss-loader，如报错没有找到某些模块，再自行安装相应模块 修改项目根目录/node_modules/react-scripts/config/webpack.config.dev.js文件 在代码 var path = require( &#39;path&#39; ); 后添加代码 12345678910111213141516var fs = require( 'fs' )const pkgPath = path.join( process.cwd(), 'package.json' );const getTheme = ( pkgPath ) =&gt; &#123;if ( fs.existsSync( pkgPath ) ) &#123; const pkg = require( pkgPath ) console.log( typeof ( pkg.theme ) ) if ( typeof ( pkg.theme ) === 'object' &amp;&amp; pkg.theme.constructor === Object ) &#123; return themeContent &#125; else &#123; const themePath = path.join( process.cwd(), pkg.theme ) const themeContent = require( themePath )() return themeContent &#125;&#125;&#125;var themeContent = JSON.stringify( getTheme( pkgPath ) ).replace( /_/g, '-' ) 然后在exclude内添加 /\\.less$/（注意添加逗号） 在loaders对象数组内添加（注意添加逗号） 1234&#123; test: /\\.less$/, loader: 'style!css!postcss!less?&#123;modifyVars:' + themeContent + '&#125;'&#125; 修改根目录的package.json文件，添加代码 1\"theme\": \"./theme.js\" 在根目录添加theme.js文件，文件中代码如下，brand_primary为主题色，如需修改其他颜色，可进入node_modules/antd-mobile/lib/style/theme/default.less查看以作相应修改 123module.exports = () =&gt; (&#123; brand_primary: 'green',&#125;) 修改.balelrc内的&quot;style&quot;: &quot;css&quot;为&quot;style&quot;: true 大功告成","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"antd-mobile","slug":"antd-mobile","permalink":"http://yoursite.com/tags/antd-mobile/"}]},{"title":"关于react的事件代理","slug":"关于react的事件代理","date":"2017-08-27T12:06:01.000Z","updated":"2017-09-10T05:27:16.557Z","comments":true,"path":"2017/08/27/关于react的事件代理/","link":"","permalink":"http://yoursite.com/2017/08/27/关于react的事件代理/","excerpt":"","text":"今天在写react列表的时候在想，我们给每个列表元素绑定事件,如果元素很多不就造成浪费了么所以写了个列表研究下react的事件绑定render内代码如下123456789const listData = [1, 2, 3, 4, 5]const liList = listData.map(( ele, index ) =&gt; &lt;li key=&#123;index&#125; onClick=&#123;() =&gt; console.log( index )&#125;&gt; &#123;ele&#125; &lt;/li&gt;)return ( &lt;ul&gt;&#123;liList&#125;&lt;/ul&gt;) 打开chrome发现 li 元素上绑定有两个事件 将两个绑定的事件remove后再点击 li 元素，发现还是能console出相应的index=。=然后网上翻了下，找到了原因:jsx不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的listener，然后通过事件的target找到真实的触发元素，这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，react都会触发相应的事件处理函数，这就是所谓的react模拟事件系统随后在chrome中删除了body上绑定的点击事件后果然不再console出index了。","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"今天开始","slug":"今天开始","date":"2017-08-20T10:08:07.000Z","updated":"2017-09-10T05:32:14.834Z","comments":true,"path":"2017/08/20/今天开始/","link":"","permalink":"http://yoursite.com/2017/08/20/今天开始/","excerpt":"","text":"今天是17年8月20日，原来一直有打算搭个博客来记录一些东西，不过由于拖延癌的原因直到现在才弄完，虽然弄完也只花了几个钟头2333，总之，加油吧 自己","categories":[],"tags":[]}]}