{"meta":{"title":"Aurora","subtitle":"CODE === INTEREST","description":"陈燕飞的博客","author":"妫乙","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2017-08-31T07:09:54.000Z","updated":"2017-12-14T09:26:18.010Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"❀❀❀ 北京 前端 陈 chenyanfei_m@foxmail.com❀❀❀"}],"posts":[{"title":"babel按需加载插件的实现","slug":"babel按需加载插件的实现","date":"2019-02-28T16:00:00.000Z","updated":"2019-03-07T09:37:47.776Z","comments":true,"path":"2019/03/01/babel按需加载插件的实现/","link":"","permalink":"http://yoursite.com/2019/03/01/babel按需加载插件的实现/","excerpt":"","text":"首先对插件的实现效果进行分析：12345678910111213// 以下形式的语法由于已经引入了整个module所以不需要作处理import defaultExport from \"module-name\";import * as name from \"module-name\";import defaultExport, &#123; export , [...] &#125; from \"module-name\";import defaultExport, * as name from \"module-name\";import \"module-name\";var promise = import(\"module-name\");// 需要作处理的语法import &#123; export &#125; from \"module-name\";import &#123; export as alias &#125; from \"module-name\";import &#123; export1 , export2 &#125; from \"module-name\";import &#123; export1 , export2 as alias2 , [...] &#125; from \"module-name\"; 可以看出，需要作处理的语句有以下特征： 是 impoort 语句 语句中有大括号且大括号外无其他引入的导出 我们想要的效果：123456// transfrom之前import &#123;export1 , export2 as alias2&#125; from \"module-name\"// transfrom之后import export1 from \"module-name/export1\"import alias2 from \"module-name/export2\" 插件代码如下：12345678910111213141516171819202122232425262728module.exports = function (&#123; types: t &#125;) &#123; const genImportDeclaration = (specifier, libraryName) =&gt; &#123; return t.importDeclaration( [t.importDefaultSpecifier(specifier.local)], t.stringLiteral(`$&#123;libraryName&#125;/$&#123;specifier.imported.name.replace(/^./, s =&gt; s.toLowerCase())&#125;`) ) &#125; return &#123; // 访问者模式, 通过对AST的遍历对访问到的ImportDeclaration作处理 visitor: &#123; // 筛选特征1 ImportDeclaration(path, &#123; opts: &#123; libraryName &#125; &#125;) &#123; // 如果没有指定moduleName if (!libraryName) return // 如果语句的source value不为libraryName if (path.node.source.value !== libraryName) return const &#123; specifiers &#125; = path.node // 筛选特征 const allAreImportSpecifier = specifiers.every(ele =&gt; ele.type === 'ImportSpecifier') if (!allAreImportSpecifier) return // 遍历所有specifier, 将其属性传入genImportDeclaration函数生成一个或多个ImportDeclaration const ImportDeclarations = specifiers.map(ele =&gt; genImportDeclaration(ele, libraryName)) // 替换原来的ImportDeclaration path.replaceWithMultiple(ImportDeclarations) &#125; &#125; &#125;&#125; 至此，便实现了一个基本的按需加载插件(完整的代码)，可以通过 babel index.js 查看转换后的效果","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"AngularJS Git Commit Message Conventions","slug":"AngularJS Git Commit Message Conventions","date":"2018-12-28T12:15:30.000Z","updated":"2018-12-28T08:16:13.929Z","comments":true,"path":"2018/12/28/AngularJS Git Commit Message Conventions/","link":"","permalink":"http://yoursite.com/2018/12/28/AngularJS Git Commit Message Conventions/","excerpt":"","text":"提交消息的格式:12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 每行提交消息的长度不能超过100个字符。message由header，body(可选)，footer(可选)组成，使用空行进行分隔。 Message headerheader部分只有一行，包含对更改内容的简单描述。包括type，可选的scope以及subject。 type用以描述此次提交的更改类型。 feat 新功能(feature) fix bug修复(bug fix) docs 文档(documentation) style 格式(formatting, missing semi colons, …) refactor 重构 test 测试(when adding missing tests) chore 维护(maintain) scope用以描述此次提交的更改位置或影响范围。比如 $browser, $compile, $rootScope, ngHref, ngClick, ngView, 等等。如果没有确切的返回可以使用*。 subject用以简单的描述此次更改。 使用动词开头且使用现在时 不要将首字母大写 最后不要加. Message bodyBody用以对本次commit进行详细地描述 跟subject一样，使用现在时 包括修改的原因和与之前行为的对比 Message footer当有以下两种情况需要写footer： 不兼容的改变如果当前代码有重大更改，应该以BREAKING CHANGE这个词开头，带一个空格或者两个换行符，然后是对变动的描述，变动理由以及如何迁移。 关闭issue如果当前commit针对某个issue，可以以Closes为开头。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[]},{"title":"浏览器缓存","slug":"浏览器缓存方式","date":"2018-12-18T16:00:00.000Z","updated":"2019-03-07T09:42:54.910Z","comments":true,"path":"2018/12/19/浏览器缓存方式/","link":"","permalink":"http://yoursite.com/2018/12/19/浏览器缓存方式/","excerpt":"","text":"当浏览器发起一个请求时，浏览器会检测缓存文件是否存在，如果有缓存的话： 判断Cache-control与Expries通过Cache-control与Expries来判断缓存是否过期。 判断Etag通过If-None-Match报头来验证Etag，如果为true，服务器将会发送”304 Not Modified”的响应来告诉浏览器缓存并没有过期，可以继续使用缓存至Cache-control或Expries设置的时间。 判断Last-Modified在浏览器第一次请求某个资源的时候会有一个Last-Modified属性标记此文件在服务器端最后被修改的时间，当第二次发送请求的时候浏览器会向服务器发送If-Modified-Since报头询问第一次请求后该文件是否被修改过，如果没有则返回304，使用本地缓存。 但是如果我们需要更新或者废弃缓存该怎么办呢，毕竟这样的场景有很多：有一个缓存时间为3小时的css文件，但是有突然的样式更改需求需要在1小时内上线并看到效果。这时，通常的做法，我们通过在资源内容改变时改变资源内容的地址来强制的让用户下载新版资源，比如在文件名中嵌入hash或者版本号，形如index.a1b2c3d.css。","categories":[{"name":"Browser","slug":"Browser","permalink":"http://yoursite.com/categories/Browser/"}],"tags":[]},{"title":"简记：日常使用的Git工作流","slug":"简记日常使用的git工作流","date":"2018-11-29T01:47:20.000Z","updated":"2018-12-28T07:46:54.986Z","comments":true,"path":"2018/11/29/简记日常使用的git工作流/","link":"","permalink":"http://yoursite.com/2018/11/29/简记日常使用的git工作流/","excerpt":"","text":"fork中央仓库到自己的账号 clone fork的个人仓库到本地 git remote add upstream https://github.com/maintainer/repo 添加远程，通常我们命名为upstream git checkout -b bugfix 创建分支 do something git fetch upstream 更新远程仓库 git rebase upstream/master 如果有 unstaged changes 需要先git stash git diff 检查修改内容准备提交 git add . git commit -m &quot;bugfix: do something&quot; git push origin bugfix -u 推送分支 发起 origin/bugfix -&gt; upstream/master 的pr","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[]},{"title":"项目优化：echarts与lodash的按需加载","slug":"项目优化：echarts与lodash的按需加载","date":"2018-11-22T12:15:30.000Z","updated":"2019-03-07T09:45:03.141Z","comments":true,"path":"2018/11/22/项目优化：echarts与lodash的按需加载/","link":"","permalink":"http://yoursite.com/2018/11/22/项目优化：echarts与lodash的按需加载/","excerpt":"","text":"由于项目历史遗留, echarts与lodash都是全部打包到vendor里面的，但是显然我们并不需要全部的功能，希望改成按需加载的方式，记录下改造的过程。 首先是echarts： 最开始所有组件都是1import echarts from 'echarts' 这样的引入方式，按照官网的按需引入方法改成类似1234import echarts from 'echarts/lib/echarts'require('echarts/lib/chart/bar')require('echarts/lib/component/tooltip')require('echarts/lib/component/title') 这样的样子，但是组件太多，这样的方法手工改明显不可取，而且往后还要使用echarts的时候也还需要这样繁琐的引入，明显不是我们所需要的样子，思考了下，新建了一个echarts.js文件，在里面批量引入所需要的echarts组件再导出，这样明显会好很多：1234567export default Promise.all([ import(/* webpackChunkName: \"echarts\" */ 'echarts/lib/echarts'), import(/* webpackChunkName: \"echarts\" */ 'echarts/lib/chart/bar'), import(/* webpackChunkName: \"echarts\" */ 'echarts/lib/component/tooltip'), import(/* webpackChunkName: \"echarts\" */ 'echarts/lib/component/title'),]) 所有需要引入echarts的组件引入这个文件就ok啦，如果需要增加echarts组件的引入，只需要在这里加就好，很方便。 其次是lodash： 还是历史遗留，import _ from &#39;lodash&#39;与var _ = require(&#39;lodash&#39;)交杂其中，所幸require写法的不多，将其改为import的写法，然后引入babel插件babel-plugin-lodash，一步到位。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"JS与Android通信","slug":"JS与Android通信","date":"2018-11-13T07:25:25.000Z","updated":"2019-03-07T09:39:33.493Z","comments":true,"path":"2018/11/13/JS与Android通信/","link":"","permalink":"http://yoursite.com/2018/11/13/JS与Android通信/","excerpt":"","text":"为了了解JS与Android之间是如何通信的，所以简单的撸了如下代码： 使用Android Studio初始化一个项目，项目主要文件如下 MainActivity.java:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.aurora.myapplication;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;import android.webkit.JavascriptInterface;import android.webkit.JsResult;import android.webkit.WebChromeClient;import android.webkit.WebView;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final WebView webView = (WebView) findViewById(R.id.webview); // 点击button触发JS内定义的callJs方法 Button button = (Button) findViewById(R.id.callJs); button.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; webView.loadUrl((\"javascript: callJs('Hello JS')\")); &#125; &#125;); // 设置webView可以执行JS webView.getSettings().setJavaScriptEnabled(true); //设置webView可以弹框 webView.setWebChromeClient(new WebChromeClient()&#123; @Override public boolean onJsAlert(WebView view, String url, String message,final JsResult result)&#123; return super.onJsAlert(view,url,message,result); &#125; &#125;); class JsObject &#123; @JavascriptInterface // 定义sayHello方法 public void sayHello(String msg) &#123; Toast.makeText(MainActivity.this, msg, Toast.LENGTH_SHORT).show(); &#125; &#125; // 将Java对象注入JS上下文中，名称为\"example\" webView.addJavascriptInterface(new JsObject(), \"example\"); webView.loadUrl(\"file:///android_asset/example.html\"); &#125;&#125; activity_main.xml:12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Call JS\" android:id=\"@+id/callJs\" /&gt; &lt;WebView android:id=\"@+id/webview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt; example.html:12345678910111213141516&lt;html&gt;&lt;body&gt;&lt;h1 id=\"hello\"&gt;Call Android&lt;/h1&gt;&lt;/body&gt;&lt;script&gt; // JS调用sayHello方法 document.querySelector('#hello').addEventListener('click',() =&gt; &#123; example.sayHello('hello android') &#125;,false) // 待Java调用的方法 const callJs = (msg) =&gt; &#123; alert(msg) &#125;&lt;/script&gt;&lt;/html&gt; 总而言之，Java可以通过webView.loadUrl(javascript: xxxxxx)来触发JS中定义的方法同时，Java可以通过webView.addJavascriptInterface方法将Java对象注入JS上下文中，从而让JS可以直接调用在Java中定义的方法","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"webpack使用import()来进行代码拆分","slug":"webpack新增chunk","date":"2018-11-01T00:18:35.000Z","updated":"2019-03-07T09:46:20.154Z","comments":true,"path":"2018/11/01/webpack新增chunk/","link":"","permalink":"http://yoursite.com/2018/11/01/webpack新增chunk/","excerpt":"","text":"查看webpack的分析报告的时候发现mockjs也被打包打到vendor里, 但是其实线上是并不需要这个库, 所以希望将其打成一个单独的chunk, 只在开发环境引用, import()就有这个作用。 最开始的写法:1process.env.NODE_ENV === 'development' &amp;&amp; require('@/mock') 使用import(): 12process.env.NODE_ENV === 'development' &amp;&amp; import(/* webpackChunkName: \"mock\" */ '@/mock') 这样就会将mockjs另外再打一个chunk啦但是由于import()是异步的, 所以会发现mockjs在第一次刷新页面的时候可能不会生效所以再改进一下, 比如在Vue中利用IIFE等待它加载完成之后再实例化： 12345;(async () =&gt; &#123; process.env.NODE_ENV === 'development' &amp;&amp; await import(/* webpackChunkName: \"mock\" */ '@/mock') new Vue(&#123;&#125;)&#125;)()","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[]},{"title":"不用循环创建一个长为n各项都为m的数组 问题的引申","slug":"创建一个长为n各项都为m的数组","date":"2018-09-15T00:18:35.000Z","updated":"2019-03-07T09:42:13.230Z","comments":true,"path":"2018/09/15/创建一个长为n各项都为m的数组/","link":"","permalink":"http://yoursite.com/2018/09/15/创建一个长为n各项都为m的数组/","excerpt":"","text":"原来面试遇到过这个题, 当时我的答案大概是1234// 第一种new Array(n).fill(m)// 第二种[...new Array(n)].map(ele =&gt; m) 但是第二种其实也是一种循环, 类似的, 还有以下这种方法:1Array.from(&#123;length: n&#125;, ele =&gt; m) 深究起来, 用map, reduce类似的数组方法可以有很多方式来解决问题, 这在于js对数组空位是如何处理的, forEach, filter, reduce, every, some方法都会跳过空位, map方法会跳过空位, 但是保留空位的值, 而join会把空位视为undefined, 而undefined又会被视为空字符串. 在es6中, 明确将空位转为undefined, 所以如果使用如下方法后面再加map就可以”伪”解决这个问题, 毕竟题目不能用loop :(123456Array.from(new Array(n))[...new Array(n)]Object.entries(new Array(n))Object.keys(new Array(n))Object.values(new Array(n))// 等等 不过毕竟都说不用循环了嘛, 如果什么循环都不用怎么解决呢我想到的方法有以下几种:1234new Array(m).fill('n')Array.from(&#123;length: m&#125;).fill('n')m.repeat(n).split('')new Array(m+1).join('n').split('') OVER","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"实现一个清除console的babel插件","slug":"实现一个清除console的babel插件","date":"2018-08-08T08:10:32.000Z","updated":"2019-03-07T09:42:46.363Z","comments":true,"path":"2018/08/08/实现一个清除console的babel插件/","link":"","permalink":"http://yoursite.com/2018/08/08/实现一个清除console的babel插件/","excerpt":"","text":"本篇只讲babel插件的实现, js AST部分后面有时间再写 首先当然是新建一个文件夹啦, 名字我们叫 bar 好了 开始做准备工作: 安装babel, 略… 然后在根文件内新建一个.babelrc文件, 如果我们的插件名叫console-clear的话, .babelrc文件内容为: 12345678910111213&#123; \"plugins\": [ [ \"./console-clear\", &#123; \"ignore\": [ \"time\", \"timeEnd\" ] &#125; ] ]&#125; 由于我们把插件放在本地, 没有发布到npm上, 所以是带相对路径的ignore参数代表会被忽略的console, 比如以上会忽略console.time, console.timeEnd 新建一个待编译的js文件, 比如index.js, 内容如下: 1234console.log('foo')console.time('bar')console.error('network error')console.timeEnd('bar') 我们的插件叫console-clear, 所以就创建一个console-clear.js文件(创建一个文件夹里面再创建index.js也行), 内容如下: 12345678910111213141516module.exports = function (&#123; types: t &#125;) &#123; return &#123; visitor: &#123; ExpressionStatement(path, &#123; opts &#125;) &#123; // 拿到object与property, 比如console.log语句的object name为console, property name为log const &#123; object, property &#125; = path.node.expression.callee // 如果表达式语句的object name不为console, 不作处理 if (object.name !== 'console') return // 判断property name是不是插件配置里被忽略的 const isIgnore = (opts.ignore || []).find(ele =&gt; ele === property.name) // 如果不是, 删除此条语句 if (!isIgnore) path.remove() &#125; &#125; &#125;&#125; 命令行执行 babel index.js 发现输出就只有以下两条了: 12console.time('bar')console.timeEnd('bar') 至此, 一个清除console的babel插件就写好啦 如果你看的一脸懵b, 比如ExpressionStatement函数是干嘛的等等, 看下文档吧 插件文档这里 项目代码在这里","categories":[{"name":"Babel","slug":"Babel","permalink":"http://yoursite.com/categories/Babel/"}],"tags":[]},{"title":"运算符 in 与 hasOwnProperty 方法","slug":"in 与 hasOwnProperty","date":"2018-07-24T00:18:35.000Z","updated":"2019-03-07T09:39:25.790Z","comments":true,"path":"2018/07/24/in 与 hasOwnProperty/","link":"","permalink":"http://yoursite.com/2018/07/24/in 与 hasOwnProperty/","excerpt":"","text":"判断一个对象是否有某属性, 可以通过key in obj或者obj.hasOwnProperty(key)来判断, 那么它们有什么区别呐 Object.prototype.hasOwnProperty()只判断对象自身属性中是否具有指定的属性 而in不止会判断对象自身属性, 还包括原形链上的属性 比如: 123456789101112131415const foo = []foo.bar = undefinedconsole.log('push' in foo)//trueconsole.log(foo.hasOwnProperty('push'))//falseconsole.log('bar' in foo)//trueconsole.log(foo.hasOwnProperty('bar'))//true 常见的, 会在为对象循环赋值时通过Object.prototype.hasOwnProperty()判断是否是对象原型链上的属性, 用来防止误修改原型链上的属性","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"前端路由history与hash模式的区别和实现","slug":"前端路由browser与hash模式","date":"2018-07-19T08:10:32.000Z","updated":"2019-03-07T09:42:37.753Z","comments":true,"path":"2018/07/19/前端路由browser与hash模式/","link":"","permalink":"http://yoursite.com/2018/07/19/前端路由browser与hash模式/","excerpt":"","text":"hash模式 以#为分隔符, 通过hashchange事件来实现 history模式 通过popstate事件以及history的pushState, replaceState方法来实现 两种模式的实现详见前端路由两种模式的实现 两者比较: history模式相对于hash模式更加美观, 但刷新会出现404, 这样history就需要服务器端进行配置, 这其实也并不是一个坏事儿, 相应的, 服务端在history模式下可以获取每次请求的路径, 从而更好地提供追踪和数据分析服务, 而hash模式#后的路径服务器端并不能收到, 所以两种模式各有优劣, 不过更推荐history模式, 毕竟颜值即正义呀233","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"读《代码大全》之变量声明","slug":"读《代码大全》之变量声明","date":"2018-07-16T08:10:32.000Z","updated":"2019-03-07T09:44:22.042Z","comments":true,"path":"2018/07/16/读《代码大全》之变量声明/","link":"","permalink":"http://yoursite.com/2018/07/16/读《代码大全》之变量声明/","excerpt":"","text":"一. 数值概论 避免使用神秘数值程序主题中仅能出现的文字量就是0和1, 任何其他文字量都应该换成更有描述性的表示比如一个输入框只能输入1到100的数字, 进行判断时: 1if(1&lt;=input&lt;=100) 没有 123const min = 1const max = 100if(min &lt;= input &lt;= max) 可读性高 预防除零每次使用 “/“ 都要考虑分母会不会是0 使用类型转换来明确数值的类型int(a) 与 a , 很明显知道a是一个什么类型的数据 避免混合类型的比较 二. 整数 检查整数除法 检查整数溢出, 在做乘法或者加法的时候, 要留心可能的最大整数, 会不会超过语言允许的最大数值 检查中间结果溢出, 需要考虑的不止是结果的溢出, 还有可能在中间计算过程中会溢出 三. 浮点数 避免数量级相差巨大的数之间的加减运算 避免等量判断 四. 字符和字符串 避免使用神秘字符和字符串 如果需要支持多种语言, 使用Unicode 五. 布尔变量 用布尔变量对程序加以文档说明, 即先将比较关系赋值给变量再进行比较 用布尔变量来简化复杂的判断 六. 具名常量 使用具名常量是一种将程序”参数化”的方法 , 即把程序中可能变化的一个方面写为一个参数, 当需要对其修改时, 只改动一处就可以了, 而不必在程序中到处改动 七. 数组 确认所有的数组下标都没有超过数组的边界 如果数组是多维的, 确认下标的使用顺序是正确的","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"读《代码大全》之变量命名","slug":"读《代码大全》之变量命名","date":"2018-07-14T08:10:32.000Z","updated":"2019-03-07T09:44:12.336Z","comments":true,"path":"2018/07/14/读《代码大全》之变量命名/","link":"","permalink":"http://yoursite.com/2018/07/14/读《代码大全》之变量命名/","excerpt":"","text":"为布尔变量的命名:a. 给布尔变量赋予隐含”真/假”含义的名字b. 不要在变量的前面加上Is, 这样优点在于这样的词不能用于那些模糊的状态 , 但是这样的词要低于纯粹的状态词 , 形如 if(isGet) 与 if(ok)c. 使用肯定的变量名 为temp类型的命名 , 这样的变量通常只是因为没有完全的明白它的意义 为不简单的枚举变量命名 在为常量命名时 , 不要根据常量的内容而是常量所表达的含义进行命名 对变量命名的缩写a. 使用标准的缩写(字典里的)b. 去掉所有非前置元音 screen -&gt; scrnc. 去掉虚词 and,or,thed. 去掉无用的后缀 ing,ede. 不改变变量的含义 不追求将单词读音数字化 比如 numtostring -&gt; num2string , before -&gt; be4 避免的名字a. 避免使用令人误解的名字或缩写b. 避免使用具有相似含义的名字c. 避免使用具有不同含义但有相似名字的变量d. 避免使用发音相近的名字e. 避免在名字中使用数字f. 避免在名字中拼错单词g. 避免使用英语中经常容易拼错的单词h. 不要靠大小写来区分变量名i. 避免使用多种自然语言j. 避免使用标准类型, 变量和子程序名字k. 避免使用与变量含义完全无关的名字l. 避免使用在名字中包含易混淆的字符 只记了一下自己觉得在日常coding中自己可能做的不够好的一些点","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"记一个有趣的bug","slug":"记一个有趣的代码bug","date":"2018-07-09T08:10:32.000Z","updated":"2019-03-07T09:43:47.294Z","comments":true,"path":"2018/07/09/记一个有趣的代码bug/","link":"","permalink":"http://yoursite.com/2018/07/09/记一个有趣的代码bug/","excerpt":"","text":"写了如下代码:(伪) 12&lt;button class=\"moveBtn\"&gt;click&lt;/button&gt;&lt;div class=\"container\"&gt;&lt;/div&gt; 123456const moveBox = document.querySelector('.container')const btn = document.querySelector('.moveBtn')btn.onclick = () =&gt; &#123; moveBox.className = 'container' moveBox.className = 'container move'&#125; 123456789.container&#123; width: 100px; height: 100px; background:red;&#125;.move&#123; transition: 3s all ease; transform: translateY(100px);&#125; 本来是想实现点击按钮, div重置动画状态, 再次向下移动的 但是发现实际上并没有效果 开始天真的以为浏览器会有对className操作的优化, 所以两个修改className的操作被合并了 打开devtool发现className的确在随着button的点击发生改变 于是我把点击事件触发的函数内的代码改为了: 1234moveBox.className = 'container'setTimeout(() =&gt; &#123; moveBox.className = 'container move'&#125;, 0) 发现就可以达到想要的效果了 why ????? 仔细想了想, 大概是跟js的macrotask有一定的关系: 在原来的代码中 macrotask 顺序为: js代码 -&gt; ui render 所以点击button后执行的顺序为: 修改className为’container’ -&gt; 修改className为’container move’ -&gt; ui render 这样其实ui render只有一遍, 所以不会有动画效果 在修改后的代码中 macrotask 顺序为: js代码 -&gt; setTimeout -&gt; ui render -&gt; setTimeout内执行 -&gt; ui render 点击button: 修改className为’container’ -&gt; ui render -&gt; 修改className为’container move’ -&gt; ui render 这样就OK啦","categories":[{"name":"Browser","slug":"Browser","permalink":"http://yoursite.com/categories/Browser/"}],"tags":[]},{"title":"Shadow DOM","slug":"浏览器默认样式与shadow dom","date":"2018-05-15T08:10:32.000Z","updated":"2019-03-07T09:43:05.394Z","comments":true,"path":"2018/05/15/浏览器默认样式与shadow dom/","link":"","permalink":"http://yoursite.com/2018/05/15/浏览器默认样式与shadow dom/","excerpt":"","text":"Shadow DOM 为Web组件中的 DOM和 CSS提供了封装。Shadow DOM 使得这些东西与主文档的DOM保持分离。 可以在settings -&gt; preferences -&gt; show user agent shadow DOM处进行勾选 从而在element内显示Shadow DOM, 比如input内的div: 自定义webcomponent: 1234567891011const myElement = document.createElement('my-element')//为元素挂载Shadow DOM//mode: 一个指定Shadow DOM封装模式的字符串，可以是下列之一：// open 指定为开放的封装模式。// closed 指定为关闭的封装模式。const shadow = myElement.attachShadow(&#123; mode: 'user-agent' &#125;);//然后往shadow内添加文字shadow.innerHTML = '&lt;div&gt;这是一个shadow dom&lt;/div&gt;'//添加颜色shadow.innerHTML += '&lt;style&gt; div&#123; color:red; border: 1px solid blue; width: 15vw; &#125; &lt;/style&gt;'document.querySelector('body').appendChild(myElement) 效果如下:","categories":[{"name":"Browser","slug":"Browser","permalink":"http://yoursite.com/categories/Browser/"}],"tags":[]},{"title":"webpack require.context的使用","slug":"webpack require.context的使用","date":"2018-04-26T13:24:45.000Z","updated":"2019-03-07T09:40:36.025Z","comments":true,"path":"2018/04/26/webpack require.context的使用/","link":"","permalink":"http://yoursite.com/2018/04/26/webpack require.context的使用/","excerpt":"","text":"1require.context(directory:String, includeSubdirs:Boolean /* 可选的，默认值是 true */, filter:RegExp /* 可选的 */) require.context() 方法可以用来创建自己的（模块）上下文，这个方法有 3 个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式。 在规范的文件夹命名下可以很方便的批量引入组件。","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[]},{"title":"transform matrix","slug":"transform matrix","date":"2018-03-04T00:18:35.000Z","updated":"2019-03-07T09:40:16.218Z","comments":true,"path":"2018/03/04/transform matrix/","link":"","permalink":"http://yoursite.com/2018/03/04/transform matrix/","excerpt":"","text":"css函数matrix()用六个指定的值来指定一个均匀的2d变换矩阵，这个矩阵中的常量值是不作为参数进行传递的，其他的参数则在主要列的顺序中描述 matrix(a, b, c, d, tx, ty)是matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1)的简写 其中，abcd以number的格式来描述线性变换，tx ty以number的格式来描述变换的量 比如matrix(1, 0, 0, 1, 20, 20)相当于translate(20px, 20px)matrix(2, 0, 0, 2, 0, 0)相当于scale(2, 2)matrix(cos45°, -sin45°, sin45°, cos45°, 0, 0)相当于rotate(45deg)","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"读《css揭秘》之形状与投影","slug":"css揭秘形状","date":"2018-02-26T00:18:35.000Z","updated":"2019-03-07T09:38:29.573Z","comments":true,"path":"2018/02/26/css揭秘形状/","link":"","permalink":"http://yoursite.com/2018/02/26/css揭秘形状/","excerpt":"","text":"圆角 我们知道将正方形的border-radius设置为宽的一半可以得到一个圆, 但当border-radius设置为大于一半时, 仍然可以得到一个圆, 这是浏览器规范决定的, 它会按比例减小各个边框半径所使用的的值, 直到它们不会相互重叠位置, 不过为border-radius指定一个固定值时当tag大小改变时就不会是一个圆了, 所以将border-radius设置为50%会更好 切角切角效果也是常见的css效果之一, 原来的方法是用一个三角形盖住元素的一个角来实现此效果, 但是用css渐变就可以轻松完成这样的效果, css代码如下:123width: 100px;height: 100px;background: linear-gradient(-45deg, transparent 15px, red 0) 效果如下: 弧形切角:12345678910111213width: 100px;height: 100px;background: #66ccff;background: radial-gradient(circle at top left,transparent 15px, #66ccff 0) top left,radial-gradient(circle at top right,transparent 15px, #66ccff 0) top right,radial-gradient(circle at bottom right,transparent 15px, #66ccff 0) bottom right,radial-gradient(circle at bottom left,transparent 15px, #66ccff 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat; 效果如下: 不规则投影 上面的切角出来后很有可能还需要阴影, 这个时候不规则投影就能起到作用啦css代码如下: 1234width: 100px;height: 100px;background: linear-gradient(-45deg, transparent 15px, red 0);filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, .8)); 效果如下: 这本书的总结先写到这儿, 因为有些内容能做到非常酷炫的效果但是实际用的不是特别多就不作记录了","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"读《css揭秘》之背景与边框","slug":"css揭秘背景与边框","date":"2018-02-15T00:18:35.000Z","updated":"2019-03-07T09:38:24.668Z","comments":true,"path":"2018/02/15/css揭秘背景与边框/","link":"","permalink":"http://yoursite.com/2018/02/15/css揭秘背景与边框/","excerpt":"","text":"有些时候我们需要多重边框的效果, 这时用box-shadow就可以很容易地做到这一点, 因为他支持逗号的写法, 从而为一个元素添加多个box-shadow, 形成多重边框的效果 html代码如下:1&lt;div class=\"example\"&gt;&lt;/div&gt; css代码如下:123456.example &#123; width: 100px; height: 100px; background: red; box-shadow: 0 0 0 10px green, 0 0 0 20px yellow; &#125; 效果如下: 需要注意的点是box-shadow的行为跟border的行为并不完全一致, 这个需要通过margin或是padding来模拟多重边框占用的空间, 还有一个问题在于这个方法产生的边框在元素的外圈, 它不会响应鼠标事件, 比如悬停, 点击, 这个时候需要把box-shadow加上inset, 让它在元素的内圈进行绘制, 同时增加额外的padding来腾出空间 当我们所需要的边框只需要两层时, 我们可以先设置border然后再设置outline来达到同样的目的, 这种方法的优点在于边框样式十分灵活, 不会像box-shadow一样只能模拟实线边框, 想实现上一个效果, 通过outline实现, 则css代码如下: 12345678.example &#123; width: 100px; height: 100px; background: rgb(255, 0, 0); /* box-shadow: 0 0 0 10px green, 0 0 0 20px yellow; */ border: 10px solid green; outline: 10px solid yellow;&#125; 前面说过, box-shadow的局限在于当需要非实现边框时非常无力, 而outline则可以轻易的做到 123456789.example&#123; width: 100px; height: 100px; background: green; border: 10px solid green; outline: 1px dashed yellow; border-radius: 5px; outline-offset: -10px;&#125; 效果如下: 这种方法的需要的注意的地方在于: 只适用双层边框的场景, 当然, 如果要模拟多层也可以 outline不一定会像border一样, 在设置border-radius后产生圆角——很有可能还是直角的, 这是一个bug, 但还未被修复","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"读《css揭秘》之css编码技巧","slug":"css揭秘css编码技巧","date":"2018-02-13T00:18:35.000Z","updated":"2019-03-07T09:38:33.553Z","comments":true,"path":"2018/02/13/css揭秘css编码技巧/","link":"","permalink":"http://yoursite.com/2018/02/13/css揭秘css编码技巧/","excerpt":"","text":"我们在寻常开发中, 通常会更注重js, 但是我相信css还是有很多有用的点是值得我们学习的, 读《css揭秘》这本书有些点给了我很大的触发, 所以把认为对自己有用的点记录下来 使用百分比来替代固定长度, 或者使用一些与视口相关的单位, 比如vw, vh, vmin, vmax, 它们的值解析为视口宽度或高度的百分比 当需要在较大分辨率下得到固定的宽度时, 使用max-width而不是用width, 因为这样可以在无需媒体查询的情况下适应较小的分辨率 合理使用简写比如background:red与background-color:red, 前者的简写可以确保你得到red的纯色背景, 但是如果使用第二个的单个属性, 则有可能被background-image覆盖","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"npm install 策略","slug":"npm install 策略","date":"2018-02-10T07:25:25.000Z","updated":"2019-03-07T09:39:42.982Z","comments":true,"path":"2018/02/10/npm install 策略/","link":"","permalink":"http://yoursite.com/2018/02/10/npm install 策略/","excerpt":"","text":"没事翻了翻项目中的node_modules文件夹看看有没有名字比较有趣的包, 忽然想起来, 以前只是知道这些是项目依赖包的依赖包, 那么如果被依赖的包又依赖了一个包, 甚至是循环依赖, 那么npm该如何处理呢? 又或者, 两个包依赖了不同版本的一个包, npm又是如何处理的呢? 带着这个疑问, 研究了下npm install的策略 当执行install命令后, npm将以以下顺序执行install的动作 加载现有的node_module树 克隆树 获取package.json和各种元数据, 并添加到克隆树中 添加缺少的依赖关系, 同时, 依赖会被尽可能的添加到树的顶部, 且不会破坏其他任何模块 将原始的树和克隆的树进行比较, 并列出将原始树转换为克隆树的动作 执行所有动作, 最深的优先, 动作包括安装, 更新, 删除和移动 对于循环依赖的问题, 当包文件夹祖先树已经存在此包时, npm会拒绝安装 如果有A依赖BC, B依赖C, C依赖D的依赖关系, 那么将形成以下结构:A&nbsp;&nbsp;&nbsp;&nbsp;–B&nbsp;&nbsp;&nbsp;&nbsp;–C&nbsp;&nbsp;&nbsp;&nbsp;–D 如果有A依赖BC, B依赖C和D@v1, C依赖D@v2, 那么形成的结构如下:A&nbsp;&nbsp;&nbsp;&nbsp;–B&nbsp;&nbsp;&nbsp;&nbsp;–C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--D@v2&nbsp;&nbsp;&nbsp;&nbsp;--D@v1 由于先安装的是B包, 所以D@v1便在顶层, 而C则要另外在C包内安装D@v2包, 可以看出, 如果安装顺序不同, 则树形结构也会是不一样的 以上","categories":[{"name":"Npm","slug":"Npm","permalink":"http://yoursite.com/categories/Npm/"}],"tags":[]},{"title":"React this 绑定的5种方法","slug":"react this 绑定的5中方法","date":"2018-02-04T04:36:40.000Z","updated":"2019-03-07T09:39:51.421Z","comments":true,"path":"2018/02/04/react this 绑定的5中方法/","link":"","permalink":"http://yoursite.com/2018/02/04/react this 绑定的5中方法/","excerpt":"","text":"使用React.createClass 1onChange = &#123; this.handleChange &#125; 在createClass内this会自动绑定到组件的实例上, 但是随着ES6 class的出现, 这种方法不被推荐 在render内bind 1onChange = &#123;this.handleChange.bind(this)&#125; 这个方法的缺陷在于函数在每次render都会被重新创建, 所以会有一定的性能影响, 当然, 这种影响在大多数的程序中并不会特别大, 但是如果程序有了性能需求, 这也是一个可以优化的点 在render内使用箭头函数 1onChange = &#123;e =&gt; this.handleChange(e)&#125; 这种方法和第二种方法有同样的性能缺陷 在constructor内进行绑定 1234constructor(props)&#123; super(props) this.handleChange = this.handleChange.bind(this)&#125; 这是React doc里建议的一种提高React性能的办法, 但是由于2, 3在大部分程序中的性能影响并不明显, 而且需要写更多的代码, 于我个人来说并不愿意用他, 当一个Component内有较多的方法需要绑定时, 需要多写的代码看起来会很繁琐 在class的属性中使用箭头函数 1234567handleChange = (e) =&gt; &#123; console.log(e)&#125;render()&#123; return &lt;div onChange = &#123;this.handleChange&#125;&gt;hello world&lt;/div&gt;&#125; 这种方法的优点在于避免了2, 3方法性能消耗的同时写法又不像4那么繁琐, 不算缺点的特点在于需要传参时比较尴尬, 可以通过data-*来进行传参, 个人使用最多的方法","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[]},{"title":"web worker","slug":"web worker","date":"2018-01-26T13:24:45.000Z","updated":"2019-03-07T09:40:27.396Z","comments":true,"path":"2018/01/26/web worker/","link":"","permalink":"http://yoursite.com/2018/01/26/web worker/","excerpt":"","text":"web worker可以让一个web application在与主线程分离的后台线程中运行一个脚本操作。比如把耗时的任务放到web worker内去执行，从而可以让主线程的运行不被阻塞。 web worker兼容性如下： 由于web worker位于外部文件中，所以无法访问主线程中的window，document，parent的对象。 web worker与主线程通过postMessage来发送消息，onmessage来接受消息，terminate方法来终止web worker。同时，传递的数据是副本传递而不是引用传递，但是在web worker中可以使用window对象中一些默认的方法和属性，比如websockets，indexedDB等。 简单的demo:首先命名js文件为ww.js，内部代码如下:123onmessage = (e) =&gt; &#123; postMessage(e.data += 1)&#125; 然后在主线程中创建web worker123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=\"wBtn\" onclick=\"calculate()\"&gt;0&lt;/button&gt; &lt;script&gt; const wBtn = document.querySelector('#wBtn') const ww = new Worker('./ww.js') const calculate = () =&gt; &#123; const btnInnerText = wBtn.innerText ww.postMessage(+btnInnerText) &#125; ww.onmessage = (e) =&gt; &#123; wBtn.innerText = e.data &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击按钮效果如下：","categories":[{"name":"Browser","slug":"Browser","permalink":"http://yoursite.com/categories/Browser/"}],"tags":[]},{"title":"JS macrotask 与 microtask","slug":"js mico maco","date":"2018-01-21T07:25:25.000Z","updated":"2019-03-07T09:39:29.579Z","comments":true,"path":"2018/01/21/js mico maco/","link":"","permalink":"http://yoursite.com/2018/01/21/js mico maco/","excerpt":"","text":"首先看下面这段代码: 1234console.log(0)setTimeout(() =&gt; console.log(1),0)Promise.resolve(2).then(val =&gt; console.log(val))console.log(3) 按照直观映像, setTimeout的延时为0, console应该立即执行, 应该输出的是 0 1 2 3 然后运行代码后我们发现输出的结果为 0 3 2 1, 这是为什么呢? (因为setTimeout最小执行时间为4ms啊, 笑) 我们知道javascript是单线程的, 但是由于异步的存在, 可以”在同一时间做两件事情”；这是由于js存在两种task，一种为macrotask，比如：整体js代码，setTimeout，setInterval，setImmediate, I/O以及ui render，还有一种为microtask，比如process.nextTick，浏览器的原生Promise，Object.observe，MutationObserver。每次macrotask的代码执行后都会检查microtask内有没有代码，如果有，则取出所有的任务进行执行。 所以当浏览器执行js代码时也就创建了一个macrotask，macrotask可以有多个但是microtask只能有一个，所以以上代码经历的过程为： 浏览器执行一个macrotask(整体js代码) 检查microtask(每次macrotask执行完都会检查，后面过程就不再添加这个动作了，默认有) 执行console.log(0) 创造一个新的macrotask，为console.log(1)，挂起 创造了一个microtask，Promise.resolve(2).then(val =&gt; console.log(val))，挂起 执行console.log(3)，console出了3 检查microtask，有microtask的话将其中所有的任务全部取出进行执行，这里只有一个 执行console.log(2); 整体js代码的这个macrotask任务全部执行完成 执行下一个macrotask，就是setTimeout所在的这个，即执行了console.log(3) 此时没有任何任务队列, 代码执行完毕","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"通过将条件语句对象化来优化判断流程","slug":"通过对条件进行对象化来优化判断流程","date":"2017-12-24T01:10:57.000Z","updated":"2019-03-07T09:44:26.713Z","comments":true,"path":"2017/12/24/通过对条件进行对象化来优化判断流程/","link":"","permalink":"http://yoursite.com/2017/12/24/通过对条件进行对象化来优化判断流程/","excerpt":"","text":"在表单或者某些场景下我们通常需要对输入的值进行很多次的校验/判断 , 我们可以通过将条件语句对象化的方式来优化我们的代码123456789101112//优化之前const exampleO = (param) =&gt; &#123; if(param === 1)&#123; return 'is 1' &#125;else if(param === 2)&#123; return 'is 2' &#125;else if(param === 3)&#123; return 'is 3' &#125;else&#123; return null &#125;&#125; 123456789//优化之后const exampleT = (param) =&gt; &#123; const conditionMap = &#123; 1:'is 1', 2:'is 2', 3:'is 3', &#125; return conditionMap[param] || null&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"初识Rx.js","slug":"初识Rx.js","date":"2017-12-17T12:52:36.000Z","updated":"2019-03-07T09:42:17.644Z","comments":true,"path":"2017/12/17/初识Rx.js/","link":"","permalink":"http://yoursite.com/2017/12/17/初识Rx.js/","excerpt":"","text":"rx","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"解锁使用chrome调试微信公众号的新姿势","slug":"解锁使用chrome调试微信公众号的新姿势","date":"2017-12-10T15:52:03.000Z","updated":"2019-03-07T09:43:37.509Z","comments":true,"path":"2017/12/10/解锁使用chrome调试微信公众号的新姿势/","link":"","permalink":"http://yoursite.com/2017/12/10/解锁使用chrome调试微信公众号的新姿势/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在开发微信公众号可以很方便的使用微信开发工具来进行开发。但是当我尝试使用微信开发工具来查看没有开发权限的微信公众号的源码的时候就遇到了阻碍——并不能查看公众号的代码，因为没有开发权限。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后尝试使用fiddler来进行抓包分析，但是发现这种方式对于我查看源码的目的来说并不是特别方便。然后网上的inspect方式也比较繁琐。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后想起原来通过微信内置的浏览器的配置清除过cookie，可能还会有一些其他的配置会对查看源码有帮助，果不其然，在信息 -&gt; TBS settings -&gt; 是否打开TBS内核Inspector调试功能，勾选上。然后就可以像hybrid app一样愉快的使用chrome的inspect来查看和调试代码啦~","categories":[{"name":"Browser","slug":"Browser","permalink":"http://yoursite.com/categories/Browser/"}],"tags":[]},{"title":"获取元素最终css, async报error","slug":"琐碎-chrome-css","date":"2017-12-03T01:47:20.000Z","updated":"2019-03-07T09:43:13.226Z","comments":true,"path":"2017/12/03/琐碎-chrome-css/","link":"","permalink":"http://yoursite.com/2017/12/03/琐碎-chrome-css/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过在代码内添加debugger的方式来打断点,原来打断点都是先console一下找到代码的位置,现在可以发现可以直接加在代码里，当然，如果使用eslint的airbnb规则默认是被禁止的哈哈 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用async报错的问题，添加babel-polyfill，然后在webpack入口加上即可 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过getComputedStyle可以获取到元素render后最终使用的css，此属性为只读属性","categories":[{"name":"琐碎","slug":"琐碎","permalink":"http://yoursite.com/categories/琐碎/"}],"tags":[]},{"title":"React.PureComponent的使用","slug":"React.PureComponent","date":"2017-11-26T04:36:40.000Z","updated":"2019-03-07T09:40:09.477Z","comments":true,"path":"2017/11/26/React.PureComponent/","link":"","permalink":"http://yoursite.com/2017/11/26/React.PureComponent/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React.PureComponent与React.Component的区别在于PureComponent通过prop和state的浅对比实现了shouldComponentUpdate()； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道只要执行一次setState默认就会render一次，当使用PureComponent时，react会浅层次的对state和prop进行diff，这样可以在一定程度上提高性能。由于是浅对比的，所以深层对象可能会出错，还有就是PureComponent与忽略整个组件的子级，所以需要确保子级组件也是Pure的。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[]},{"title":"e.stopPropagation()和e.preventDefault()","slug":"关于e.stopPropagation()和e.preventDefault()","date":"2017-11-19T10:20:37.000Z","updated":"2019-03-07T09:41:18.092Z","comments":true,"path":"2017/11/19/关于e.stopPropagation()和e.preventDefault()/","link":"","permalink":"http://yoursite.com/2017/11/19/关于e.stopPropagation()和e.preventDefault()/","excerpt":"","text":"e.stopPropagation() //用来阻止事件的冒泡e.preventDefault() //用来阻止事件默认的行为return false //两者皆阻止","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"忽略eslint检测, img有莫名空白","slug":"遇到的小问题","date":"2017-11-12T13:55:36.000Z","updated":"2019-03-07T09:44:32.200Z","comments":true,"path":"2017/11/12/遇到的小问题/","link":"","permalink":"http://yoursite.com/2017/11/12/遇到的小问题/","excerpt":"","text":"通过添加在文件头部添加 /* eslint-disable */ 来忽略eslint qq浏览器 0.01rem宽度的border没有效果, 需要使用1px 0.5px line的通常做法是使用scale和after,before伪类 即使字体行高等于容器高度也有可能不垂直居中, 这种情况有可能是字体大小为奇数导致的 img有莫名空白的问题123div&#123;font-size: 0&#125;img&#123;display: block&#125;img&#123;vertical-align: top&#125; 相对来说第二种给人感觉更为正常 为a标签添加一个形如”tel:电话号码”这样的href属性可以唤起打电话","categories":[{"name":"琐碎","slug":"琐碎","permalink":"http://yoursite.com/categories/琐碎/"}],"tags":[]},{"title":"利用react高阶组件与context实现简单的状态管理","slug":"利用react高阶组件与context实现简单的状态管理","date":"2017-10-29T12:20:05.000Z","updated":"2019-03-07T09:42:32.389Z","comments":true,"path":"2017/10/29/利用react高阶组件与context实现简单的状态管理/","link":"","permalink":"http://yoursite.com/2017/10/29/利用react高阶组件与context实现简单的状态管理/","excerpt":"","text":"首先我们得知道react的context的用法：通过在context提供者中添加childContextTypes和getChildContext来添加context，然后在子组件中通过contextTypes来获取参数，通过它我们可以将数据跨组件传送。以及高阶组件的作用：高阶组件实质上就是一个函数，这个函数接受一个组件作为参数，并返回一个新的组件。 想要实现简单的状态的管理，我们需要一个存储数据的store和一个可以改变这个store内数据的动作。代码如下：react123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'class Provider extends Component &#123; //选择需要放在context上的数据和方法 static childContextTypes = &#123; store: PropTypes.object, setStore: PropTypes.func &#125; getChildContext() &#123; return &#123; store: this.state.store || &#123;&#125;, setStore: this.setStore &#125; &#125; //通过此方法来修改store内的数据 setStore = (data) =&gt; &#123; this.setState(&#123; store: &#123; ...this.state.store, ...data &#125; &#125;) &#125; //初始时的数据，如果没有从组件外传入则为空对象 state = &#123; store: this.props.store || &#123;&#125; &#125; render() &#123; return this.props.children &#125;&#125;const connect = WrapComponent =&gt; &#123; //返回一个新的传入了store与setStore方法的组件 return class connect extends Component &#123; //通过contextTypes来选择需要使用context内的数据或方法 static contextTypes = &#123; store: PropTypes.object, setStore: PropTypes.func &#125; render() &#123; const &#123; store, setStore &#125; = this.context const props = &#123; ...this.props, store, setStore &#125; return &lt;WrapComponent &#123;...props&#125;&gt;&lt;/WrapComponent &gt; &#125; &#125;&#125;export &#123; Provider, connect &#125; 需要使用时通过在组件树的高层初始化store，然后在需要使用store的子组件外通过此代码导出的connect方法包裹此子组件即可通过组件的props拿到store和setStore。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"对redux设计的理解","slug":"关于redux如此设计的理解","date":"2017-10-22T13:15:15.000Z","updated":"2019-03-07T09:41:49.217Z","comments":true,"path":"2017/10/22/关于redux如此设计的理解/","link":"","permalink":"http://yoursite.com/2017/10/22/关于redux如此设计的理解/","excerpt":"","text":"以前对于redux只是照着文档用，闲下来想了想为什么redux要这样设计呢？如果自己想实现一个状态管理的方案该会是怎样的呢？ 首先，当遇到很多状态需要集中管理的时候，我们很容易能想到通过顶层store来对状态进行集中管理，如果子组件需要此状态，可以通过hoc将store内的数据通过props传进来，与此同时传入一个可以改变顶层store内的数据的方法。这样便实现了一个最简单的状态管理方案。 然而，就这样粗浅的设计肯定会有很多的问题 比如：通常顶层的store通常会非常大，我们很可能不需要所有的store内的数据，这时可以在hoc上传一个参数，来选择性的传入需要的数据 比如：现在我们通过changeStore方法来改变store内的数据，但是，数据如何处理呢?这是一个问题，原来我们只是简单的通过传入一个对象，比如在store内的数据为{data:1}，我们通过changeStore({data:2})来将store内的数据进行改变，当我们传入的并不是一个满意的值的时候，我们就需要在changeStore和store中间加一层用来处理数据 没时间先写到这儿，这是我对redux如此设计的原因的理解，以上~","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[]},{"title":"关于JS的数据绑定","slug":"关于JS的数据绑定","date":"2017-10-15T07:23:17.000Z","updated":"2019-03-07T09:41:33.530Z","comments":true,"path":"2017/10/15/关于JS的数据绑定/","link":"","permalink":"http://yoursite.com/2017/10/15/关于JS的数据绑定/","excerpt":"","text":"发布者-订阅者模式，如backbone.js 脏值检查，如angular，对常用的dom及xhr事件做了封装，在其中会从rootscope开始进行遍历，检查所有的watcher，并不是定时轮询检查 Object.defineProperty，此属性可以设置对象的get和set，在对对象进行读写的时候就会触发相应的函数。示例代码如下： 12345678910111213let boundObj = &#123; a: 1 &#125;let resObj = &#123;&#125;boundObj.bValue = boundObj.aObject.defineProperty(boundObj, a, &#123; get()&#123; return boundObj.bValue &#125;, set(newValue)&#123; boundObj.bValue = newValue resObj.b = newValue return newValue &#125;&#125;) resObj对象的b属性便与boundObj的a属性绑定了 proxy，通过设置set来进行绑定，相对于Object.defineProperty来说更加简洁，不再需要中间变量123456789const boundObj = &#123; a: 1 &#125;let resObj = &#123;&#125;boundObj.proxy = new Proxy(boundObj,&#123; set(target, prop, value, receiver)&#123; target[prop] = value resObj[prop] = value return true &#125;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"移动端页面宽高设置","slug":"移动端页面宽高设置","date":"2017-10-05T01:08:47.000Z","updated":"2019-03-07T09:43:25.281Z","comments":true,"path":"2017/10/05/移动端页面宽高设置/","link":"","permalink":"http://yoursite.com/2017/10/05/移动端页面宽高设置/","excerpt":"","text":"原来设置移动端页面蠢蠢的从html标签body标签一路往下设置宽高为100%，都忘了12345.root&gt;div&#123; position:absolute; width:100%; height:100% &#125; 这种写法了，蠢哭","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"flex使用复习","slug":"flex使用总结","date":"2017-10-05T00:18:35.000Z","updated":"2019-03-07T09:39:13.832Z","comments":true,"path":"2017/10/05/flex使用总结/","link":"","permalink":"http://yoursite.com/2017/10/05/flex使用总结/","excerpt":"","text":"在日常学习和工作中使用flex也有一段时间了，刚好现在有空闲时间，来对flex再复习一遍吧 flex相对与传统的css布局可以用更少的代码达到相同的目的，尤其在常用的布局上，使用flex可以很轻松的达到目的。 首先通过display:flex或display:inline-flex来为一个容器指定为flex布局。当指定为flex布局后，容器内的子元素的float，clear，vertical-align将会失效。容器默认的轴为从左上角开始，向右为水平的主轴，向下为垂直的交叉轴。 flex容器可以设置的6个属性。 flex-direction决定了主轴的方向，可以为row：从左往右（default);row-reverse：从右往左；column：从上往下；column-reverse：从下往上。 flex-warp决定了容器内的元素是否能够换行，nowrap：顾名思义，不换行；wrap：换行；wrap-reverse：倒序换行。 flex-flow为flex-direction和flex-wrap属性的简写，默认为row nowrap。 justify-content决定了元素在主轴上如何对齐。flex-start：靠主轴开始的地方对齐；flex-end：靠主轴接受䣌地方对齐；center：居中对齐；space-between：两端元素在两笔，中间元素均分空间对齐；space-around：两端元素有一段空间，中间元素均分剩余空间。 align-items决定了容器内元素在交叉轴上如何对齐。flex-start：交叉轴起点对齐；flex-end：交叉轴终点对齐；center：居中对齐；stretch：如果元素未设置高度或为auto，那么元素将为容器高度的100%；baseline：以容器内的第一行文字的基线对齐。 align-content决定了容器内有多根轴线时的对齐方式，如果只有一根轴线，那么设置此属性无效。同样的，可以为flex-start，flex-end，center，space-between，space-around，stretch。 flex容器内元素可设置的值 order决定了元素的排列顺序，默认为0 flex-grow决定了元素的放大比例，即除了元素已经确定了的空间之外的空间的比例，如果flex-grow小于1，那么就是直接将剩余宽度乘以flex-grow的值而不会再计算比例，flex-grow会受到max-width的影响，max-width的优先级更高。 flex-shark用于在空间不够时控制元素的收缩，比如只有一个元素设置了这个，那么这个元素将会被收缩至合适的宽度。 flex-basis决定了元素在分配多余的空间之前占的主轴的空间。默认为auto flex为flex-grow，flex-shrink，flex-basis的简写，默认为0 1 auto。如果为auto则为1 1 auto，如果为none则为0 0 auo，如果为1则为1 1 0。 align-self属性为单个元素设置与其他元素不一样的对齐方式。优先级高于align-items。默认为auto，即继承父元素的align-items属性。如果没有父元素则为stretch。 总而言之，flex-grow用于将剩余空间按比例分配给元素，flex-shark用于将超出部分按比例分配给元素。 此篇总结借鉴了网上一些教程，在此处感谢他们♥","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"关于移动端的布局问题","slug":"关于移动端的布局问题","date":"2017-09-24T02:54:54.000Z","updated":"2019-03-07T09:41:55.191Z","comments":true,"path":"2017/09/24/关于移动端的布局问题/","link":"","permalink":"http://yoursite.com/2017/09/24/关于移动端的布局问题/","excerpt":"","text":"关于移动端常见的上下bar中间content scroll的布局，我原来的写法是content height:100%，然后再把上下bar fix在screen的上下，然而这样的布局是有很大的问题的。首先是滚动条的问题, 当以上面的方法来进行布局的时候，滚动区域位于上下bar之间, 滚动条却可以滚动到屏幕的最上方，这明显不符合直观的UI逻辑；二是很多时候下方的bar都是一个输入框，而在ios中fixed的定位可能会出现bug：当键盘出现时，此bar很可能会被弹到screen的中间。所以自己想了想该如何布局比较好，总结如下：HTML：1234567&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"scrollContainer\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/div&gt; CSS：123456789101112131415161718.container&#123; position: absolute; width: 100%; height: 100%;&#125;.header, .footer&#123; height: 50px;&#125;.scrollContainer&#123; margin: -50px 0; padding: 50px 0; height: 100%; box-sizing: border-box;&#125;.content&#123; height: 100%; overflow-y: scroll;&#125; 如果使用flex:1234567891011121314.container&#123; position: absolute; display: flex; flex-direction: column; height: 100%; width: 100%;&#125;.header,.footer&#123; flex: 0 0 50px&#125;.scrollContainer&#123; flex: 1; overflow-y: scroll;&#125; 相对于传统css布局，flex使用更少的css和html即可达到想要的效果","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[]},{"title":"fetch发送请求携带cookie","slug":"fetch发送请求携带cookie","date":"2017-09-10T05:14:11.000Z","updated":"2019-03-07T09:39:06.974Z","comments":true,"path":"2017/09/10/fetch发送请求携带cookie/","link":"","permalink":"http://yoursite.com/2017/09/10/fetch发送请求携带cookie/","excerpt":"","text":"fetch默认不发送cookie , 发送cookie需要配置credential为include , 还不行? 服务器端配置Access-Control-Allow-Credentials为true , 还不行的话看看remote adress是不是你请求的那个地址 , 还有就是cookie是不是保存在请求的地址的下面","categories":[{"name":"Browser","slug":"Browser","permalink":"http://yoursite.com/categories/Browser/"}],"tags":[]},{"title":"build文件的相对路径","slug":"build文件的相对路径","date":"2017-09-09T12:15:30.000Z","updated":"2019-03-07T09:45:44.201Z","comments":true,"path":"2017/09/09/build文件的相对路径/","link":"","permalink":"http://yoursite.com/2017/09/09/build文件的相对路径/","excerpt":"","text":"通过在package.json内添加homepage可以修改打包后的路径","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[]},{"title":"关于es6的async","slug":"关于es6的async","date":"2017-09-08T11:40:36.000Z","updated":"2019-03-07T09:41:27.830Z","comments":true,"path":"2017/09/08/关于es6的async/","link":"","permalink":"http://yoursite.com/2017/09/08/关于es6的async/","excerpt":"","text":"async返回的是一个promise , 所以在内部return后需要then来拿async返回的值 , 同时 , 在内部使用Promise.resolve(value) , 外部通过then也不能获取值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[]},{"title":"关于chrome请求发送不出去的问题","slug":"关于chrome请求发送不出去的问题","date":"2017-09-07T12:15:42.000Z","updated":"2019-03-07T09:41:13.580Z","comments":true,"path":"2017/09/07/关于chrome请求发送不出去的问题/","link":"","permalink":"http://yoursite.com/2017/09/07/关于chrome请求发送不出去的问题/","excerpt":"","text":"如果发现浏览器发送请求发送不出去 , 最好看下是不是被浏览器广告插件一类的东西拦截了 , 装了Adblock Plus插件的人的血泪教训233","categories":[{"name":"Browser","slug":"Browser","permalink":"http://yoursite.com/categories/Browser/"}],"tags":[]},{"title":"请求参数为中文的兼容性问题","slug":"请求参数为中文的兼容性问题","date":"2017-09-05T13:54:35.000Z","updated":"2019-03-07T09:43:58.291Z","comments":true,"path":"2017/09/05/请求参数为中文的兼容性问题/","link":"","permalink":"http://yoursite.com/2017/09/05/请求参数为中文的兼容性问题/","excerpt":"","text":"请求中有可能传中文的 , 需要先使用encodeURIComponent将参数进行转码","categories":[{"name":"琐碎","slug":"琐碎","permalink":"http://yoursite.com/categories/琐碎/"}],"tags":[]},{"title":"antd-mobile修改主题样式的问题","slug":"react-antd-mobile修改主题样式的问题","date":"2017-08-29T07:53:33.000Z","updated":"2019-03-07T09:40:00.936Z","comments":true,"path":"2017/08/29/react-antd-mobile修改主题样式的问题/","link":"","permalink":"http://yoursite.com/2017/08/29/react-antd-mobile修改主题样式的问题/","excerpt":"","text":"方法为通过less-loader的modifyVars来修改原来的默认less，需要安装style-loader，css-loader，less-loader，postcss-loader，如报错没有找到某些模块，再自行安装相应模块 修改项目根目录/node_modules/react-scripts/config/webpack.config.dev.js文件 在代码 var path = require( &#39;path&#39; ); 后添加代码 12345678910111213141516var fs = require( 'fs' )const pkgPath = path.join( process.cwd(), 'package.json' );const getTheme = ( pkgPath ) =&gt; &#123;if ( fs.existsSync( pkgPath ) ) &#123; const pkg = require( pkgPath ) console.log( typeof ( pkg.theme ) ) if ( typeof ( pkg.theme ) === 'object' &amp;&amp; pkg.theme.constructor === Object ) &#123; return themeContent &#125; else &#123; const themePath = path.join( process.cwd(), pkg.theme ) const themeContent = require( themePath )() return themeContent &#125;&#125;&#125;var themeContent = JSON.stringify( getTheme( pkgPath ) ).replace( /_/g, '-' ) 然后在exclude内添加 /\\.less$/（注意添加逗号） 在loaders对象数组内添加（注意添加逗号） 1234&#123; test: /\\.less$/, loader: 'style!css!postcss!less?&#123;modifyVars:' + themeContent + '&#125;'&#125; 修改根目录的package.json文件，添加代码 1\"theme\": \"./theme.js\" 在根目录添加theme.js文件，文件中代码如下，brand_primary为主题色，如需修改其他颜色，可进入node_modules/antd-mobile/lib/style/theme/default.less查看以作相应修改 123module.exports = () =&gt; (&#123; brand_primary: 'green',&#125;) 修改.balelrc内的&quot;style&quot;: &quot;css&quot;为&quot;style&quot;: true 大功告成","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[]},{"title":"关于react的事件代理","slug":"关于react的事件代理","date":"2017-08-27T12:06:01.000Z","updated":"2019-03-07T09:41:40.857Z","comments":true,"path":"2017/08/27/关于react的事件代理/","link":"","permalink":"http://yoursite.com/2017/08/27/关于react的事件代理/","excerpt":"","text":"今天在写react列表的时候在想，我们给每个列表元素绑定事件,如果元素很多不就造成浪费了么所以写了个列表研究下react的事件绑定render内代码如下123456789const listData = [1, 2, 3, 4, 5]const liList = listData.map(( ele, index ) =&gt; &lt;li key=&#123;index&#125; onClick=&#123;() =&gt; console.log( index )&#125;&gt; &#123;ele&#125; &lt;/li&gt;)return ( &lt;ul&gt;&#123;liList&#125;&lt;/ul&gt;) 打开chrome发现 li 元素上绑定有两个事件 将两个绑定的事件remove后再点击 li 元素，发现还是能console出相应的index=。=然后网上翻了下，找到了原因:jsx不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的listener，然后通过事件的target找到真实的触发元素，这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，react都会触发相应的事件处理函数，这就是所谓的react模拟事件系统随后在chrome中删除了body上绑定的点击事件后果然不再console出index了。","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[]},{"title":"今天开始","slug":"今天开始","date":"2017-08-20T10:08:07.000Z","updated":"2017-09-10T05:32:14.834Z","comments":true,"path":"2017/08/20/今天开始/","link":"","permalink":"http://yoursite.com/2017/08/20/今天开始/","excerpt":"","text":"今天是17年8月20日，原来一直有打算搭个博客来记录一些东西，不过由于拖延癌的原因直到现在才弄完，虽然弄完也只花了几个钟头2333，总之，加油吧 自己","categories":[],"tags":[]}]}