{"meta":{"title":"陈工","subtitle":"我见青山多妩媚，料青山、见我应如是。","description":"陈燕飞的博客","author":"妫乙","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2017-08-31T07:09:54.000Z","updated":"2017-08-31T09:54:56.377Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"❀❀❀ 北京 前端 小陈 ❀❀❀"}],"posts":[{"title":"flex使用复习","slug":"flex使用总结","date":"2017-10-05T00:18:35.000Z","updated":"2017-10-05T01:01:05.194Z","comments":true,"path":"2017/10/05/flex使用总结/","link":"","permalink":"http://yoursite.com/2017/10/05/flex使用总结/","excerpt":"","text":"在日常学习和工作中使用flex也有一段时间了，刚好现在有空闲时间，来对flex再复习一遍吧 flex相对与传统的css布局可以用更少的代码达到相同的目的，尤其在常用的布局上，使用flex可以很轻松的达到目的。 首先通过display:flex或display:inline-flex来为一个容器指定为flex布局。当指定为flex布局后，容器内的子元素的float，clear，vertical-align将会失效。容器默认的轴为从左上角开始，向右为水平的主轴，向下为垂直的交叉轴。 flex容器可以设置的6个属性。 flex-direction决定了主轴的方向，可以为row：从左往右（default);row-reverse：从右往左；column：从上往下；column-reverse：从下往上。 flex-warp决定了容器内的元素是否能够换行，nowrap：顾名思义，不换行；wrap：换行；wrap-reverse：倒序换行。 flex-flow为flex-direction和flex-wrap属性的简写，默认为row nowrap。 justify-content决定了元素在主轴上如何对齐。flex-start：靠主轴开始的地方对齐；flex-end：靠主轴接受䣌地方对齐；center：居中对齐；space-between：两端元素在两笔，中间元素均分空间对齐；space-around：两端元素有一段空间，中间元素均分剩余空间。 align-items决定了容器内元素在交叉轴上如何对齐。flex-start：交叉轴起点对齐；flex-end：交叉轴终点对齐；center：居中对齐；stretch：如果元素未设置高度或为auto，那么元素将为容器高度的100%；baseline：以容器内的第一行文字的基线对齐。 align-content决定了容器内有多根轴线时的对齐方式，如果只有一根轴线，那么设置此属性无效。同样的，可以为flex-start，flex-end，center，space-between，space-around，stretch。 flex容器内元素可设置的值 order决定了元素的排列顺序，默认为0 flex-grow决定了元素的放大比例，即除了元素已经确定了的空间之外的空间的比例，如果flex-grow小于1，那么就是直接将剩余宽度乘以flex-grow的值而不会再计算比例，flex-grow会受到max-width的影响，max-width的优先级更高。 flex-shark用于在空间不够时控制元素的收缩，比如只有一个元素设置了这个，那么这个元素将会被收缩至合适的宽度。 flex-basis决定了元素在分配多余的空间之前占的主轴的空间。默认为auto flex为flex-grow，flex-shrink，flex-basis的简写，默认为0 1 auto。如果为auto则为1 1 auto，如果为none则为0 0 auo，如果为1则为1 1 0。 align-self属性为单个元素设置与其他元素不一样的对齐方式。优先级高于align-items。默认为auto，即继承父元素的align-items属性。如果没有父元素则为stretch。 总而言之，flex-grow用于将剩余空间按比例分配给元素，flex-shark用于将超出部分按比例分配给元素。 此篇总结借鉴了网上一些教程，在此处感谢他们♥","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://yoursite.com/tags/flex/"}]},{"title":"关于移动端的布局问题","slug":"关于移动端的布局问题","date":"2017-09-24T02:54:54.000Z","updated":"2017-09-25T03:33:56.381Z","comments":true,"path":"2017/09/24/关于移动端的布局问题/","link":"","permalink":"http://yoursite.com/2017/09/24/关于移动端的布局问题/","excerpt":"","text":"关于移动端常见的上下bar中间content scroll的布局，我原来的写法是content height:100%，然后再把上下bar fix在screen的上下，然而这样的布局是有很大的问题的。首先是滚动条的问题, 当以上面的方法来进行布局的时候，滚动区域位于上下bar之间, 滚动条却可以滚动到屏幕的最上方，这明显不符合直观的UI逻辑；二是很多时候下方的bar都是一个输入框，而在ios中fixed的定位可能会出现bug：当键盘出现时，此bar很可能会被弹到screen的中间。所以自己想了想该如何布局比较好，总结如下：HTML：1234567&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"scrollContainer\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/div&gt; CSS：123456789101112131415161718.container&#123; position: absolute; width: 100%; height: 100%;&#125;.header, .footer&#123; height: 50px;&#125;.scrollContainer&#123; margin: -50px 0; padding: 50px 0; height: 100%; box-sizing: border-box;&#125;.content&#123; height: 100%; overflow-y: scroll;&#125; 如果使用flex:1234567891011121314.container&#123; position: absolute; display: flex; flex-direction: column; height: 100%; width: 100%;&#125;.header,.footer&#123; flex: 0 0 50px&#125;.scrollContainer&#123; flex: 1; overflow-y: scroll;&#125; 相对于传统css布局，flex使用更少的css和html即可达到想要的效果","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"fetch发送请求携带cookie","slug":"fetch发送请求携带cookie","date":"2017-09-10T05:14:11.000Z","updated":"2017-09-11T04:39:05.764Z","comments":true,"path":"2017/09/10/fetch发送请求携带cookie/","link":"","permalink":"http://yoursite.com/2017/09/10/fetch发送请求携带cookie/","excerpt":"","text":"fetch默认不发送cookie , 发送cookie需要配置credential为include , 还不行? 服务器端配置Access-Control-Allow-Credentials为true , 还不行的话看看remote adress是不是你请求的那个地址 , 还有就是cookie是不是保存在请求的地址的下面","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"fetch","slug":"fetch","permalink":"http://yoursite.com/tags/fetch/"}]},{"title":"build文件的相对路径","slug":"build文件的相对路径","date":"2017-09-09T12:15:30.000Z","updated":"2017-09-10T05:30:44.274Z","comments":true,"path":"2017/09/09/build文件的相对路径/","link":"","permalink":"http://yoursite.com/2017/09/09/build文件的相对路径/","excerpt":"","text":"通过在package.json内添加homepage可以修改打包后的路径","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"关于es6的async","slug":"关于es6的async","date":"2017-09-08T11:40:36.000Z","updated":"2017-09-10T05:33:56.900Z","comments":true,"path":"2017/09/08/关于es6的async/","link":"","permalink":"http://yoursite.com/2017/09/08/关于es6的async/","excerpt":"","text":"async返回的是一个promise , 所以在内部return后需要then来拿async返回的值 , 同时 , 在内部使用Promise.resolve(value) , 外部通过then也不能获取值","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"关于chrome请求发送不出去的问题","slug":"关于chrome请求发送不出去的问题","date":"2017-09-07T12:15:42.000Z","updated":"2017-09-10T06:28:33.527Z","comments":true,"path":"2017/09/07/关于chrome请求发送不出去的问题/","link":"","permalink":"http://yoursite.com/2017/09/07/关于chrome请求发送不出去的问题/","excerpt":"","text":"如果发现浏览器发送请求发送不出去 , 最好看下是不是被浏览器广告插件一类的东西拦截了 , 装了Adblock Plus插件的人的血泪教训233","categories":[{"name":"遇到的值的记下来的小点","slug":"遇到的值的记下来的小点","permalink":"http://yoursite.com/categories/遇到的值的记下来的小点/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"}]},{"title":"请求参数为中文的兼容性问题","slug":"请求参数为中文的兼容性问题","date":"2017-09-05T13:54:35.000Z","updated":"2017-09-10T06:28:16.655Z","comments":true,"path":"2017/09/05/请求参数为中文的兼容性问题/","link":"","permalink":"http://yoursite.com/2017/09/05/请求参数为中文的兼容性问题/","excerpt":"","text":"请求中有可能传中文的 , 需要先使用encodeURIComponent将参数进行转码","categories":[{"name":"遇到的值的记下来的小点","slug":"遇到的值的记下来的小点","permalink":"http://yoursite.com/categories/遇到的值的记下来的小点/"}],"tags":[]},{"title":"antd-mobile修改主题样式的问题","slug":"react-antd-mobile修改主题样式的问题","date":"2017-08-29T07:53:33.000Z","updated":"2017-09-25T05:11:17.824Z","comments":true,"path":"2017/08/29/react-antd-mobile修改主题样式的问题/","link":"","permalink":"http://yoursite.com/2017/08/29/react-antd-mobile修改主题样式的问题/","excerpt":"","text":"方法为通过less-loader的modifyVars来修改原来的默认less，需要安装style-loader，css-loader，less-loader，postcss-loader，如报错没有找到某些模块，再自行安装相应模块 修改项目根目录/node_modules/react-scripts/config/webpack.config.dev.js文件 在代码 var path = require( &#39;path&#39; ); 后添加代码 12345678910111213141516var fs = require( 'fs' )const pkgPath = path.join( process.cwd(), 'package.json' );const getTheme = ( pkgPath ) =&gt; &#123;if ( fs.existsSync( pkgPath ) ) &#123; const pkg = require( pkgPath ) console.log( typeof ( pkg.theme ) ) if ( typeof ( pkg.theme ) === 'object' &amp;&amp; pkg.theme.constructor === Object ) &#123; return themeContent &#125; else &#123; const themePath = path.join( process.cwd(), pkg.theme ) const themeContent = require( themePath )() return themeContent &#125;&#125;&#125;var themeContent = JSON.stringify( getTheme( pkgPath ) ).replace( /_/g, '-' ) 然后在exclude内添加 /\\.less$/（注意添加逗号） 在loaders对象数组内添加（注意添加逗号） 1234&#123; test: /\\.less$/, loader: 'style!css!postcss!less?&#123;modifyVars:' + themeContent + '&#125;'&#125; 修改根目录的package.json文件，添加代码 1\"theme\": \"./theme.js\" 在根目录添加theme.js文件，文件中代码如下，brand_primary为主题色，如需修改其他颜色，可进入node_modules/antd-mobile/lib/style/theme/default.less查看以作相应修改 123module.exports = () =&gt; (&#123; brand_primary: 'green',&#125;) 修改.balelrc内的&quot;style&quot;: &quot;css&quot;为&quot;style&quot;: true 大功告成","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"antd-mobile","slug":"antd-mobile","permalink":"http://yoursite.com/tags/antd-mobile/"}]},{"title":"关于react的事件代理","slug":"关于react的事件代理","date":"2017-08-27T12:06:01.000Z","updated":"2017-09-10T05:27:16.557Z","comments":true,"path":"2017/08/27/关于react的事件代理/","link":"","permalink":"http://yoursite.com/2017/08/27/关于react的事件代理/","excerpt":"","text":"今天在写react列表的时候在想，我们给每个列表元素绑定事件,如果元素很多不就造成浪费了么所以写了个列表研究下react的事件绑定render内代码如下123456789const listData = [1, 2, 3, 4, 5]const liList = listData.map(( ele, index ) =&gt; &lt;li key=&#123;index&#125; onClick=&#123;() =&gt; console.log( index )&#125;&gt; &#123;ele&#125; &lt;/li&gt;)return ( &lt;ul&gt;&#123;liList&#125;&lt;/ul&gt;) 打开chrome发现 li 元素上绑定有两个事件 将两个绑定的事件remove后再点击 li 元素，发现还是能console出相应的index=。=然后网上翻了下，找到了原因:jsx不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的listener，然后通过事件的target找到真实的触发元素，这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，react都会触发相应的事件处理函数，这就是所谓的react模拟事件系统随后在chrome中删除了body上绑定的点击事件后果然不再console出index了。","categories":[{"name":"react相关","slug":"react相关","permalink":"http://yoursite.com/categories/react相关/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"今天开始","slug":"今天开始","date":"2017-08-20T10:08:07.000Z","updated":"2017-09-10T05:32:14.834Z","comments":true,"path":"2017/08/20/今天开始/","link":"","permalink":"http://yoursite.com/2017/08/20/今天开始/","excerpt":"","text":"今天是17年8月20日，原来一直有打算搭个博客来记录一些东西，不过由于拖延癌的原因直到现在才弄完，虽然弄完也只花了几个钟头2333，总之，加油吧 自己","categories":[],"tags":[]}]}